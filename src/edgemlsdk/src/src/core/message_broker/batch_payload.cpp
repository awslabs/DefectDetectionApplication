#include <vector>
#include <algorithm>

#include <nlohmann/json.hpp>

#include <core/message_broker/payload_base.h>
#include <Panorama/chrono.h>
#include <Panorama/message_broker.h>

using namespace Panorama;

class BatchPayload : public UnknownImpl<IBatchPayload>, public PayloadBase
{
public:
    static HRESULT Create(IBatchPayload** ppObj)
    {
        COM_FACTORY(BatchPayload, Initialize());
    }

    ~BatchPayload()
    {
        COM_DTOR_FIN(BatchPayload);
    }

    int32_t Count() override
    {
        return _payloads.size();
    }

    HRESULT Payload(IPayload** ppObj, const char* id) override
    {
        CHECKNULL(ppObj, E_POINTER);
        CHECKNULL(id, E_INVALIDARG);
        
        // Expect get by id to be called rarely, and the batch sizes to generally be small.
        // Searching the vector rather than keeping a separate map to save on memory, and trading off for lookup efficiency.
        auto it = std::find_if(_payloads.begin(), _payloads.end(), [&id](const ComPtr<IPayload>& payload){
            // Payload id is autogenerated and should always be a valid c-str
            // If the given id somehow differs after matching the entire randomly generated payload id, I think they deserve the payload
            return strncmp(payload->Id(), id, strlen(payload->Id())) == 0;
        });

        if (it == _payloads.end())
        {
            return E_NOT_FOUND;
        }

        it->AddRef();
        *ppObj = it->Ptr();
        return S_OK;
    }

    HRESULT Payload(IPayload** ppObj, int32_t idx) override
    {
        CHECKNULL(ppObj, E_POINTER);
        CHECKIF(idx < 0 || idx >= _payloads.size(), E_OUTOFRANGE);

        _payloads[idx].AddRef();
        *ppObj = _payloads[idx].Ptr();
        return S_OK;
    }

    HRESULT AddPayload(IPayload* payload) override
    {
        CHECKNULL(payload, E_INVALIDARG);
        
        // Users technically able, although highly discouraged, to create circular references of batch payloads - for example: batch1 [batch2 [batch1 [...]]]
        // Can't prevent this without child batch payloads having knowledge of which parents they have.
        // Especially since child payloads can have payloads added to them afterwards. Let's just leave it for now.
        
        // Batch payload cannot contain itself
        CHECKIF(this == payload, E_INVALIDARG);
        _payloads.emplace_back(payload);
        return S_OK;
    }

    /**
     * Buffer is set to a snapshot of the serialization manifest
    */
    HRESULT Serialize(IBuffer** ppObj) override
    {
        HRESULT hr = S_OK;
        CHECKNULL(ppObj, E_POINTER);
        CHECKHR(CreateBufferFromString(ppObj, GetSerializationManifest().c_str()));
        return hr;
    }

    /**
     * Buffer is set to a snapshot of the serialization manifest
     * Returned c str is valid until this function is called again, at which point the internal buffer is overwritten
     * Returns nullptr on failure
    */
    const char* SerializeAsString() override
    {
        HRESULT hr = S_OK;
        ComPtr<IBuffer> tmp;
        CHECK_FAIL(CreateBufferFromString(tmp.AddressOf(), GetSerializationManifest().c_str()), nullptr);
        _serializeAsStringBuffer = tmp;
        return _serializeAsStringBuffer->AsString();
    }

private:
    BatchPayload() = default;

    HRESULT Initialize()
    {
        _timestamp = NowAsTimestamp();
        _id = GuidToString(GenerateGuid());
        return S_OK;
    }

    std::string GetSerializationManifest()
    {
        nlohmann::json manifest;
        manifest["timestamp"] = Timestamp();
        manifest["id"] = Id();
        manifest["correlation_id"] = CorrelationId();
        
        std::vector<nlohmann::json> payloadsMetaData(_payloads.size());
        std::transform(_payloads.begin(), _payloads.end(), payloadsMetaData.begin(), [](const ComPtr<IPayload> & i) {
            nlohmann::json j;
            j["timestamp"] = i->Timestamp();
            j["id"] = i->Id();
            j["correlation_id"] = i->CorrelationId();
            return j;
        });
        manifest["payload_count"] = _payloads.size();
        manifest["payloads"] = payloadsMetaData;
        return manifest.dump();
    }

    std::vector<ComPtr<IPayload> > _payloads;

    // Buffer to keep the returned c str memory alive
    ComPtr<IBuffer> _serializeAsStringBuffer;
};

DLLAPI HRESULT CreateEmptyBatchPayload(IBatchPayload** ppObj)
{
    return BatchPayload::Create(ppObj);
}
